#include <iostream>
/*
Програма написана у Visual Studio 2019, студентом ПМІ-12, Білоскурським Валерієм.
*/
/*
Метод сортування гнома полягає в тому, що ми будемо знаходитися між двома числами і перевіряти чи стоять вони на свому місці чи треба їх міняти.
Уразі зміни ми повертаємось назад і перевіряємо до поки все буде на своїх місцях.
Ось ще приклад гномика, якщо два сусідні від гнома горщики йдуть у правильному порядку, гном йде на одну позицію вперед.
Якщо ж вони у неправильному порядку - міняє ці два горщики місцями і йде на одну позицію назад (щоб знову перевірити порядок).
*/
/*

*/
using namespace std;
int main()
{
    srand(time(NULL));//Для задання рандомних чисел.
    int rozmir;//Створюємо зміну, якій будемо надавати значення каількості елементів в масиві.
    int i;
    /*task 1, гнома*/
    cout << "enter the numbers of elements in the array: " << endl;
    cin >> rozmir;
    int* array;
    array = new int[rozmir];//створення динамічного масиву.
    cout << "array #1: " << endl;
    for (i = 0; i < rozmir; i++)//З використанням циклу заповнємо елементи масиву рандомними числами за допомогою srand(time(NULL)).
    {
        array[i] = rand() % 100;
        cout << array[i] << " ";
    }
    cout << endl;
    int j = 2;
    i = 1;//Створюємо елементи i та j для роботи з сортуванням.
    while (i < rozmir)//цикл буде працювати тоді коли і менше за кількість елементів масиву.
    {
        if (array[i - 1] < array[i]) {//Перевіряємо чи наступний елемент більший за попередній, якщо так, томи рухаємось на один елемент дальше.
            i = j;
            j++;
        }
        else/*Якщо ні, тоді ми створюємо нову зміну, і за допомогою цієї зміної, міняємо два елементи масиву місцями,
            після чого ми будемо повторювати провірку поки елементи не стануть у посортованій послідовності,
            після чого ми повернемось до першочергової перевірки.
            */
        {
            int zamina = array[i];
            array[i] = array[i - 1];
            array[i - 1] = zamina;
            i--;
            if (i == 0) {
                i = j;
                j++;
            }
        }
    }
    cout << "sorted array: " << endl;
    for (i = 0; i < rozmir; i++)//Ввиводимо наш посортований масив елементів.
    {
        cout << array[i] << " ";
    }
    cout << "\n\n";
    delete[] array;//Виклик delete[] для масиву об'єктів призведе до виклику деструктора кожного об'єкта перед звільненням пам'яті, виділеної під масив.
    /*task 2, комірками*/
    int* array1 = new int[rozmir];//Створємо другий динамічний масив.
    cout << "array #2: " << endl;
    for (int i = 0; i < rozmir; i++)//З використанням циклу заповнємо елементи масиву рандомними числами за допомогою srand(time(NULL)).
    {
        array1[i] = rand() % 100;
        cout << array1[i] << " ";
    }
    cout << endl;
    int element_porivnyanya;
    for (int i = 1, j; i < rozmir; ++i)/*Починаючи з другого елементу, дістаємо його з циклу, в ту зміну запамятовуємо змінну порівняння,
                                       і дальше порівнюємо всі попередні елементи з тим елементом порівняння, якщо попередній елемент більший ніж елемент порівняння,
                                       тоді ми їх всіх посуваємо і так будемо робити поки не дійдемо до елемента який буде менший за цей елемент порівняння,
                                       або поки не дойдемо до нульового індексу і тоді вже ставимо елемент порівняння який ми вже раніше дістали з циклу.
                                       */
    {
        element_porivnyanya = array1[i];
        for (j = i - 1; j >= 0 && array1[j] > element_porivnyanya; --j)
        array1[j + 1] = array1[j];
        array1[j + 1] = element_porivnyanya;
    }
    cout << "sorted array: " << endl;
    for (int i = 0; i < rozmir; i++)//Ввиводимо посортований масив.
    {
        cout << array1[i] << " ";
    }
    cout << "\n\n";
    delete[]array1; //Виклик delete[] для масиву об'єктів призведе до виклику деструктора кожного об'єкта перед звільненням пам'яті, виділеної під масив.
    system("pause");
    return 0;
}
